# -*- coding: utf-8 -*-
"""LSTM_vgt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/119BtIqFhoTTBIty6sZTfSbAi-3euhngz
"""

pip install darts

import math
from sklearn.metrics import mean_squared_error
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from darts import TimeSeries
from darts.dataprocessing.transformers import Scaler
from darts.models import RNNModel, ExponentialSmoothing, BlockRNNModel
from darts import TimeSeries

!gdown --id '1oGNPbgmH0NDyOg4o4ZFhi0ZLzqXK0ccC' --output vgt.csv
path = 'vgt.csv'
vgt = pd.read_csv(path)
# .drop()
# data.drop(axis=0, columns=[data['date']], inplace=True)

# plot utils.
def plot_scatter(*args, **kwargs):
    plt.plot(*args, **kwargs)
    plt.scatter(*args, **kwargs)


# simple batcher.
def data_generator(x, y, size):
    assert len(x) == len(y)
    batches = []
    for ii in range(0, len(x), size):
        batches.append((x[ii:ii + size], y[ii:ii + size]))
    for batch in batches:
        yield batch

p = vgt["Price"]
print(p.head())
p = p.values.flatten()  # just keep np array here for simplicity.
lp = np.log(p)  # log
gp = lp[1:] - lp[:-1]  # difference
milk = gp

df = pd.DataFrame(gp,columns=['diff'],dtype=float)
norm_constant = np.max(df['diff'])
abc = df['diff'].values/norm_constant
series = TimeSeries.from_values(abc)

    
#abcd = [range(4607), abc]
#abcde = pd.DataFrame(abcd,columns=['str','diff'])
type(series)

train, val = series.split_after(0.8)

lstm_model = RNNModel(
    model="LSTM",
    hidden_dim=20,
    dropout=0,
    batch_size=30,
    n_epochs=8,
    model_name="LSTM_VGT",
    log_tensorboard=True,
    random_state=1000,
    training_length=20,
    input_chunk_length=7,
    force_reset=True,
    save_checkpoints=True,
)

lstm_model.fit(train,
    val_series=val,
    verbose=True,
)

pred_series = lstm_model.historical_forecasts(
    series,
    start=0.8,
    forecast_horizon=3,
    stride=1,
    retrain=False,
    verbose=True
)

m = pred_series.pd_dataframe()
n = m.to_numpy()

k = []
for i in n:
    for j in i:
        j = j * float(norm_constant)
        k.append(j)

gp1 = k + lp[3686:-1]
gp2=[]
for m in gp1:
    gp2.append(math.exp(m))

MSE = mean_squared_error(k,gp[3686:] )
RMSE = math.sqrt(MSE)

print("RMSE:",RMSE)
